<!DOCTYPE html>
<html style="background-color: #FFFFFF; height: 100%; width: 100%;">

<script type="text/javascript" src="deps/dat.gui.min.js"></script>
<script src="deps/js-snackbar.min.js"></script>
<link rel="stylesheet" href="deps/codemirror.css">
<link rel="stylesheet" href="deps/fs.css">
<script src="deps/codemirror.js"></script>
<script src="deps/glsl.js"></script>
<script src="deps/foldcode.js"></script>
<script src="deps/brace-fold.js"></script>
<script src="deps/foldgutter.js"></script>
<script src="deps/matchbrackets.js"></script>
<script src="deps/search.js"></script>
<script src="deps/searchcursor.js"></script>
<script src="deps/dialog.js"></script>
<link rel="stylesheet" href="deps/js-snackbar.min.css" />
<link rel="stylesheet" href="deps/dialog.css" />
<link rel="stylesheet" href="deps/foldgutter.css" />
<script type="text/javascript" src="deps/show-hint.js"></script>
<link type='text/css' rel="stylesheet" href="deps/show-hint.css">

<body style="height: 100%; width: 100%; display: flex; justify-content: center;
  overflow: hidden;">
  <div style="display: flex; height: 100%; width: 95%;">
    <div style="height: 100%; flex: auto;
        display: flex; align-items: center; justify-content: center; 
        flex-direction: column;">
      <canvas style="height: 400px; width: 400px;" id="canvas" class="canvas">
      </canvas>
      <div id="controls" style="width: 100%; background-color:aliceblue;
      display: flex;">
        <div style=" display: flex;">
          <span id="time" contenteditable
            style="margin-right: 2px; margin-left: 8px;">
            0.00</span>s
          <span id="fps" style="margin-left: 20px; margin-right: 2px;">
            0.0
          </span>fps
        </div>
      </div>
      <div id="textures" style="width: 100%;
      display: flex; margin-top: 8px; margin-left: 8px;">

        <div style="display: flex; 
        flex-direction: column; ">
          <img id="texture0" crossorigin="anonymous"
            style="background-color: #333; height: 80px; width: 80px; margin-right: 16px; border:1px solid black; border-radius: 5px;" />
          <span style="width: 80px; text-align: center;">tex0</span>
        </div>
        <div style="display: flex; 
        flex-direction: column;">
          <img id="texture1" crossorigin="anonymous"
            style="background-color: #333; height: 80px; width: 80px; margin-right: 16px; border:1px solid black; border-radius: 5px;" />
          <span style="width: 80px; text-align: center;">tex1</span>
        </div>
        <div style="display: flex; 
        flex-direction: column;">
          <img id="texture2" crossorigin="anonymous"
            style="background-color: #333; height: 80px; width: 80px; margin-right: 16px; border:1px solid black; border-radius: 5px;" />
          <span style="width: 80px; text-align: center;">tex2</span>
        </div>
        <div style="display: flex; 
        flex-direction: column;">
          <img id="texture3" crossorigin="anonymous"
            style="background-color: #333; height: 80px; width: 80px; margin-right: 16px; border:1px solid black; border-radius: 5px;" />
          <span style="width: 80px; text-align: center;">tex3</span>
        </div>
      </div>
    </div>
    <div id="code" style="top: 5%; height: 90%; margin-left: 20px;
       opacity: 97%; display: flex; align-items: center;">
       <div id="funcs" style="display: flex; flex-direction: column;
       align-self: start;">
        <span id="togglefuncs" class="collapsible">Builtins</span>
        <div style="display: block" class="content">
          <textarea id="funcstext">
          </textarea>
        </div>
       </div>
      <textarea id="textarea" style="height: 100%;">
      </textarea>
    </div>
  </div>
  <div style="display: block;
    position: absolute; bottom: 0px; left: 10px; right: 10px;">
    <input id="command" style="width: 100%; display: none;">
  </div>

  <dialog id="help_dialog" style="background-color: rgb(184 184 184 / 88%);
  border-radius: 5px;">
    <div style="display: flex; flex-direction: column;">
      <h4 style="align-self: center;">Help (Esc to close)</h4>
      <p>
        This is a mini hacked version of
        <a href="https://www.shadertoy.com" target="_blank">Shadertoy</a>.<br>
        It has some tricks to make it easier to fine tune variables, and plenty
        of shortcuts.
      </p>
      <table style="width: 100%; background-color: #999;">
        <tr>
          <th colspan="4" style="background-color: #333; color:#FFFFFF">
            Shortcuts</th>
        </tr>
        <tr style="background-color: #777;">
          <td>⌘/Alt/Ctrl + Enter</td>
          <td>Compile</td>
          <td>⌘/Ctrl + 1</td>
          <td>Show gui</td>
        </tr>
        <tr>
          <td>⌥/Alt/Ctrl + F</td>
          <td>Toggle fullscreen</td>
          <td>⌘/Ctrl + 2</td>
          <td>Show controls</td>
        </tr>
        <tr style="background-color: #777;">
          <td>Drag image to tex</td>
          <td>Load texture</td>
          <td>⌘/Ctrl + 3</td>
          <td>Show/hide textures</td>
        </tr>
        <tr>
          <td>⌥/Alt + ↑ </td>
          <td>Start/Stop time</td>
          <td>⌥/Alt + ↓ </td>
          <td>Reset time</td>
        </tr>
        <tr style="background-color: #777;">
          <td>~</td>
          <td>Show/hide editor</td>
          <td>Ctrl + ~</td>
          <td>Command prompt</td>
        </tr>
        <tr>
          <td>⌘/Ctrl + S</td>
          <td>Quick save</td>
          <td>⌘/Ctrl + O</td>
          <td>Quick load</td>
        </tr>
        <tr style="background-color: #777;">
          <td colspan="2">(Select val) ⌘/Ctrl + E</td>
          <td colspan="2">Extract uniform</td>

        </tr>
        <tr>
          <td colspan="2">(Select uniform) ⌘/Ctrl + E</td>
          <td colspan="2">Replace with value</td>
        </tr>
        <tr style="background-color: #777;">
          <td colspan="2">⌘/Alt + canvas click + mouse move</td>
          <td colspan="2">Resize canvas</td>
        </tr>
        <tr>
          <td colspan="2">canvas click + mouse move</td>
          <td colspan="2">Control mouse variable</td>
        </tr>
        <tr style="background-color: #777;">
          <td colspan="2">shift + mouse move</td>
          <td colspan="2">Make it move faster</td>
        </tr>
      </table>
    </div>
  </dialog>

</body>

<script>

  const autoUniformRegex = /\/\*\s*([a-z\d]+)\s*\*\/\s*([a-zA-Z\d\_]+)/g;
  const assignmentRegex = /([a-zA-Z\d\_\.]+)\s*\=/g;
  const vec2Vals = /\((\d*\.?\d*)\s*\,\s*(\d*\.?\d*)\)/g;
  const vec3Vals = /\((\d*\.?\d*)\s*\,\s*(\d*\.?\d*)\s*,\s*(\d*\.?\d*)\)/g;
  const vec4Vals = /\((\d*\.?\d*)\s*\,\s*(\d*\.?\d*)\s*,\s*(\d*\.?\d*)\s*,\s*(\d*\.?\d*)\)/g;

  const codeElem = document.getElementById('code');
  const dialogElement = document.getElementById('help_dialog');
  const commandElem = document.getElementById('command');
  const timeElem = document.getElementById('time');
  const fpsElem = document.getElementById('fps');
  let lastFpsTimestamp, framesCount;
  const FLOAT_PRECISION = `#version 300 es
   precision mediump float;
    out vec4 fragColor;
    `
  const FRAG_SHADER_PREFIX = 
`// Shadertoy compatibility
#define iResolution res
#define iFrame 0
#define HW_PERFORMANCE 0
#define iTime time
#define iMouse mouse
#define PI 3.14159265359

// Textures and their resolutions.
uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform sampler2D tex3;
uniform vec2 res0;
uniform vec2 res1;
uniform vec2 res2;
uniform vec2 res3;

// Screen resolution.
uniform vec2 res;
// Elapsed time in seconds.
uniform float time;
// Mouse coords (x, y, wheel).
uniform vec3 mouse;
`;
  const FRAG_SHARDER_SUFFIX = `
  void main() {
      vec4 temp = vec4(0.0);
      mainImage(temp, gl_FragCoord.xy);
      fragColor = vec4(temp.xyz, 1.0);
    }
  `;

  const magicFuncs = new Map();

  const vsSource =
    "#version 300 es\n in vec4 aVertexPosition; void main(){gl_Position = aVertexPosition;}";

  const fsSource = 
`
// Uncomment to control the camera with the mouse.
//#define INTERACTIVE

float mainBox(vec3 p) {
  return sdBox(p, vec3(0.2, 0.2, 0.2));
}

float cutSphere(vec3 p) {
  p.z *= 0.3;
  return sdSphere(p, 0.03);
}

vec2 map2(vec3 p) {
  float ang = (2.+2.*sin(time-PI/2.))*atan(p.y, p.z);
  p = rotate(p, vec3(1., 0., 0.), ang);
  vec2 d1 = vec2(mainBox(p), 1.0);
  float v = 0.05;
  for (int i = 0; i < 4; i++) {
    p = mod(p + v, 2.*v) - v;
    float d2 = cutSphere(p);
    d1.x = smax(d1.x, -d2, 0.01);
    p *= 2.;
  }
  return d1;
}

void mainImage(out vec4 color, in vec2 pix) {
  color = vec4(1.);
  vec2 p = (pix * 2.0 - res) / res.y;
  // Ray origin & direction.
  vec3 ro, rd;
  
  #ifdef INTERACTIVE
  orbitMouseCam(p, vec3(0.), ro, rd);
  #else
  // Fly around the object.
  ro = 1. * vec3(sin(time+PI/7.), 0, cos(time+PI/7.));
  ro.y = 0.2+0.2*sin(time+PI/4.);
  rd = rayDir(p, vec3(0.), ro);
  #endif
  // March and apply color if hit.
  float t = raymarch(ro, rd, 0., 100.);
  if (t >= 0.) {
    color = colorize(ro + t * rd, rd);
  }
  // Apply post processing effects.
  color = gammaCorrect(color);
  color *= vignette(pix, 0.2);
}`;

  var _transitions = [

  ];

  const AUTO_COMPILE_DELAY_MS = 250;

  const canvas = document.getElementById("canvas");
  const controls = document.getElementById('controls');
  const texturesElem = document.getElementById('textures');
  const texture0 = document.getElementById('texture0');
  const texture1 = document.getElementById('texture1');
  const texture2 = document.getElementById('texture2');
  const texture3 = document.getElementById('texture3');
  const allTextures = [texture0, texture1, texture2, texture3];
  const gl = canvas.getContext("webgl2");
  const input = document.getElementById("textarea");
  input.value = fsSource;
  let editor, funcEditor;

  const textures = [null, null, null, null];
  var autoCompile = false;
  let gShaderProgram = null;
  let gBuffers = null;
  let gProgramInfo = null;
  let triggerCompilerTimeout = null;
  let compilePromise = null;
  let gUniforms = new Map();
  let uniformsGui = {};
  const guiControllers = new Map();
  let configGui = {
    aspect_ratio: 1.777, width: 400, animate: false,
    builtin_funcs: true,
    endlessMouse: true,
    clearStorage: () => localStorage.clear(),
    quickSave: () => {
      localStorage.setItem('code', editor.getValue());
      SnackBar({
        status: 'success', message: 'Saved + Sharing URL copied to clipboard',
        timeout: 3000
      });
    },
    quickLoad: () => {
      const code = localStorage.getItem('code');
      if (!!code) {
        editor.setValue(code);
        SnackBar({
          status: 'success', message: 'Loaded',
          timeout: 1000
        });
        compile();
      } else {
        SnackBar({
          status: 'error', message: 'No saved code exists',
          timeout: 1000
        });
      }
    },
  };
  let selectedElem, lastMousePos;
  let animateController;
  let lastTimestamp = null;
  let mouse = { x: 0.0, y: 0.0, z: 0.0 };
  let mouseControllers = [];
  let sizeControllers = [];
  let gui = new dat.GUI();

  function initBuffers(gl) {
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    const positions = [1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0];
    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array(positions),
      gl.STATIC_DRAW
    );
    return { position: positionBuffer };
  }

  function createTexture(source) {
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

    gl.texImage2D(
      gl.TEXTURE_2D,
      0,
      gl.RGBA,
      gl.RGBA,
      gl.UNSIGNED_BYTE,
      source
    );

    return texture;
  }

  function initShaderProgram(gl, vsSource, fsSource, lineShift) {
    const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource, lineShift);
    if (vertexShader == null) {
      return null;
    }
    const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource, lineShift);
    if (fragmentShader == null) {
      gl.deleteShader(vertexShader);
      return null;
    }
    const shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);
    gl.deleteShader(vertexShader);
    gl.deleteShader(fragmentShader);
    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
      console.log(
        "Unable to initialize the shader program: " +
        gl.getProgramInfoLog(shaderProgram)
      );
      gl.deleteProgram(shaderProgram);
      return null;
    }
    return shaderProgram;
  }

  function unique(arr) {
    return [...new Set(arr)];
  }

  function reportErrorCompilingShader(msg, lineShift) {
    const errorLines = unique([...msg.matchAll(/0\:\d+/g)].map(x => x[0]));
    errorLines.forEach(l => {
      const splt = l.split(':');
      const newLine = parseInt(splt[1]) - lineShift + 1;
      msg = msg.replaceAll(l, `${splt[0]}:${newLine}`);
      editor.addLineClass(newLine - 1, 'background', 'redBackground');
    });
    msg = msg.replaceAll('\n', '<br>');
    SnackBar({
      message: msg, status: 'error', timeout: false
    });
  }

  function loadShader(gl, type, source, lineShift) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      reportErrorCompilingShader(gl.getShaderInfoLog(shader), lineShift);
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }

  function drawScene(canvas, gl, programInfo, buffers) {
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    {
      const numComponents = 2;
      const type = gl.FLOAT;
      const normalize = false;
      const stride = 0;
      const offset = 0;
      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
      gl.vertexAttribPointer(
        programInfo.attribLocations.vertexPosition,
        numComponents,
        type,
        normalize,
        stride,
        offset
      );
      gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
    }
    gl.useProgram(programInfo.program);
    gl.uniform2f(
      programInfo.uniformLocations.res,
      canvas.width,
      canvas.height
    );
    gl.uniform3f(
      programInfo.uniformLocations.mouse,
      mouse.x,
      mouse.y,
      mouse.z,
    );
    gl.uniform1f(programInfo.uniformLocations.time, parseFloat(timeElem.innerText));
    updateTextures();
    updateUniformValues();
    {
      const offset = 0;
      const vertexCount = 4;
      gl.drawArrays(gl.TRIANGLE_STRIP, offset, vertexCount);
    }
  }

  function initializeMagicFuncs() {
    magicFuncs.set('sdCircle',{ code:
`float sdCircle(vec2 p, float r) {
  return length(p) - r;
}`});
    magicFuncs.set('sdBox', { code:
`float sdBox(vec2 p, vec2 b) {
  vec2 d = abs(p)-b;
  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
}
float sdBox(vec3 p, vec3 b) {
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}`});
    magicFuncs.set('sdEqTriangle', { code:
`float sdEqTriangle( in vec2 p ) {
  const float k = sqrt(3.0);
  p.x = abs(p.x) - 1.0;
  p.y = p.y + 1.0/k;
  if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;
  p.x -= clamp( p.x, -2.0, 0.0 );
  return -length(p)*sign(p.y);
}`});
    magicFuncs.set('sdTriangle', {code:
`float sdTriangle(vec2 p, vec2 p0, vec2 p1, vec2 p2 ) {
    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;
    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;
    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );
    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );
    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );
    float s = sign( e0.x*e2.y - e0.y*e2.x );
    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),
                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),
                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));
    return -sqrt(d.x)*sign(d.y);
}`});
    magicFuncs.set('smin', { code:
`float smin(float a, float b, float k) {
  float h = max( k-abs(a-b), 0.0 );
  return min( a, b ) - h*h/k*0.25;
}`});
magicFuncs.set('smax', {deps: ['smin'], code:
`float smin(float a, float b, float k);
float smax(float a, float b, float k) {
  return -smin(-a, -b, k);
}`});
    magicFuncs.set('sdSegment', { code:
`float sdSegment( in vec2 p, in vec2 a, in vec2 b ) {
  vec2 pa = p-a, ba = b-a;
  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
  return length( pa - ba*h );
}`});
    magicFuncs.set('sdSphere', { code:
`float sdSphere(in vec3 p, float r) {
  return length(p) - r;
}`});
    magicFuncs.set('hash', { code:
`float hash(float p) {
  return fract(25625.66*sin(683.12*p));
}
float hash(vec2 p) {
  return fract(14524.12*sin(123.34*p.x+55.1234*p.y));
}
float hash(vec3 p) {
  return fract(87625.123*sin(52.865*p.x+124.63*p.y+672.12*p.z));
}`});
    magicFuncs.set('hash2', { code:
`vec2 hash2(float p) {
  return vec2(fract(82653.124*sin(473.24*p)),
              fract(14253.64*sin(2561.3*p)));
}
vec2 hash2(vec2 p) {
  return vec2(fract(14524.12*sin(123.34*p.x+55.1234*p.y)),
              fract(51364.16*sin(352.21*p.x+1413.34*p.y)));
}
vec2 hash2(vec3 p) {
  return vec2(fract(65234.23*sin(542.2*p.x+124.3*p.y+643.*p.z)),
              fract(5251.4*sin(423.3*p.x+111.23*p.y+125.3*p.x)));
}`});
    magicFuncs.set('hash3', { code:
`vec3 hash3(float p) {
  return vec3(fract(14524.12*sin(123.34*p)),
              fract(51364.16*sin(352.21*p)),
              fract(96234.55*sin(56.13*p)));
}
vec3 hash3(vec2 p) {
  return vec3(fract(14524.12*sin(123.34*p.x+55.1234*p.y)),
              fract(51364.16*sin(352.21*p.x+1413.34*p.y)),
              fract(96234.55*sin(56.13*p.x+235.142*p.y)));
}`});
    magicFuncs.set('vnoise', {deps: ['hash'], code:
`float hash(vec2 p);
float vnoise(vec2 p){
  vec2 i = floor(p);
  vec2 f = fract(p);
  f = f*f*(3.0-2.0*f);

  return mix(
      mix(hash(i), hash(i + vec2(1.0,0.0)),f.x),
      mix(hash(i + vec2(0.0,1.0)), hash(i + vec2(1.0,1.0)), f.x),
      f.y);
}`});
    magicFuncs.set('fbm', {deps: ['vnoise'], code:
`float vnoise(vec2 p);
float fbm(vec2 p) {
  float res = 0.;
  float amp = 0.5;
  for (int i = 0; i < 8; i++) {
    res += amp * vnoise(p);
    amp *= 0.5;
    p *= 2.;
  }
  return res;
}`});
    magicFuncs.set('map2', {code:
`vec2 map2(vec3 p) {
  return vec2(1.0, 1.0);
}
`});
    magicFuncs.set('map', {deps: ['map2'], code:
`vec2 map2(vec3 p);
float map(vec3 p) {
  return map2(p).x;
}
`});
    magicFuncs.set('sdfNormal', {deps: ['map'], code:
`float map(vec3 p);
vec2 map2(vec3 p);
vec3 sdfNormal(vec3 pos, float eps) {
  vec2 e = vec2(0.5773,-0.5773);
  return normalize(
      e.xyy*map(pos + e.xyy*eps) + 
			e.yyx*map(pos + e.yyx*eps) + 
			e.yxy*map(pos + e.yxy*eps) + 
			e.xxx*map(pos + e.xxx*eps));
}`});
    magicFuncs.set('colorize', {
      deps: ['calcAO', 
      'map2','chooseColor', 'mainLight', 'backLight', 'sdfNormal'], 
      code:
`vec3 mainLight(vec3 p, vec3 n, vec3 rd);
vec3 backLight(vec3 p, vec3 n);
float calcAO(vec3 pos, vec3 nor);
vec3 sdfNormal(vec3 pos, float eps);
vec2 map2(vec3 p);
vec3 chooseColor(vec3 p, vec3 rd, vec3 n, float id);
vec4 colorize(vec3 p, vec3 rd) {
  vec3 col = vec3(0.);
  vec3 n = sdfNormal(p, 1e-4);
  // Material color.
  vec3 mat = chooseColor(p, rd, n, map2(p).y);

  // Apply main light.
  col += mat * mainLight(p, n, rd) * /*float*/ main_light_intensity;

  // Fake ambient occlusion.
  float ao = calcAO(p, n);

  // Apply back light.
  col += ao * mat * backLight(p, n) * /*float*/ back_light_intensity;
  return vec4(col, 1.0);
}
`});
magicFuncs.set('rotate', {code:
`vec3 rotate(vec3 p, vec3 axis, float angle) {
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;
    
    return (mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                0.0,                                0.0,                                0.0,                                1.0) 
            * vec4(p, 1.0)).xyz;
}`});
    magicFuncs.set('chooseColor', {deps: ['hash3', 'map2'], code: 
`vec3 hash3(float p);
vec2 map2(vec3 p);
vec3 chooseColor(vec3 p, vec3 rd, vec3 n, float id) {
  return normalize(hash3(map2(p).y)) * 0.3;
}
`});
    magicFuncs.set('raymarch', {deps: ['map2'], code:
`vec2 map2(vec3 p);
float raymarch(vec3 ro, vec3 rd, float tmin, float tmax) {
  float t = tmin;
  int i = 0;
  for(; i<80; i++ ) {
    float dist = map2(ro + t * rd).x;

    // Break if we're close enough to the surface.
    if(abs(dist)<(0.15*t/res.x)) break;

    t += dist * 0.6;
    // Break if we exceeded tmax.
    if( t>tmax ) return -1.0;
  }
  return t;
}`});
magicFuncs.set('calcShadow', {deps: ['map'], code:
`float map(vec3 p);
float calcShadow(vec3 ro, vec3 rd, float tmin, float tmax) {
  float t = tmin;
  float shadow = 1.0;
  for(int i = 0; i<100; i++ ) {
    float dist = map2(ro + t * rd).x;
    t += clamp(dist, 0.02, 0.3);
    shadow = min(shadow, dist / t);
    // Break if we're close enough to the surface.
    if(shadow<1e-3 || t > tmax) break;
  }
  return clamp(shadow, 0., 1.);
}`});
    magicFuncs.set('orbitMouseCam', {deps: ['rayDir'], code:
`vec3 rayDir(vec2 p, vec3 lookat, vec3 ro);
void orbitMouseCam(vec2 p, vec3 lookat, out vec3 ro, out vec3 rd) {
  float d = 1. + mouse.z / res.x / 2.;
  ro = d * vec3(sin(2.*mouse.x / res.x), 0, cos(2.*mouse.x / res.x));
  ro.y = 2.*mouse.y / res.y;

  rd = rayDir(p, lookat, ro);
}`});
    magicFuncs.set('rayDir', {code:
`vec3 rayDir(vec2 p, vec3 lookat, vec3 ro) {
  vec3 up = vec3(0., 1., 0.);
  vec3 cz = normalize(lookat - ro);
  vec3 lr = cross(cz, up);
  vec3 ud = cross(lr, cz);

  return normalize( p.x*lr + p.y*ud + 2.5*cz );
}`});
    magicFuncs.set('mainLight', {deps: ['calcShadow'], code:
`float calcShadow(vec3 ro, vec3 rd, float tmin, float tmax);
vec3 mainLight(vec3 p, vec3 n, vec3 rd) {
  vec3 ld = normalize(/*vec3*/main_light_dir);
  // Diffuse.
  float d = clamp(0.5+0.5*dot(n, ld), 0., 1.);
  float sh = calcShadow(p, ld, 0.02, 50.);
  vec3 col = sh * d * /*col*/ main_light_color;

  // Specular.
  vec3 hal = normalize(ld-rd);
  float s = clamp(dot(n,hal), 0.0, 1.0);
  float fre = clamp(dot(-rd,ld), 0.0, 1.0);
  col += pow(s, 8.)*d*sh*pow(fre,5.0);
  return col;
}`});
  magicFuncs.set('backLight', { code:
`vec3 backLight(vec3 p, vec3 n) {
  float d = clamp(dot(n, - normalize(/*vec3*/main_light_dir)), 0., 1.);
  return d * /*col*/ back_light_color;
}`});
    magicFuncs.set('min2', {code:
`vec2 min2(vec2 a, vec2 b) {
  return a.x < b.x? a : b;
}`});
magicFuncs.set('vignette', {code:
`float vignette(vec2 pix, float intensity) {
  vec2 p = pix / res;
  return pow(16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y), intensity);
}`});
magicFuncs.set('gammaCorrect', {code:
`vec4 gammaCorrect(vec4 color) {
  return vec4(pow(color.xyz, vec3(0.4545)), 1.0);
}`});
magicFuncs.set('calcAO', {deps: ['map'], code:
`float map(vec3 p);
float calcAO(vec3 pos, vec3 nor) {
	float totao = 0.0;
  float sc = 1.0;
  for(int i=0; i<5; i++ ) {
      float ed = 0.01 + 0.05*float(i);
      vec3 aopos =  nor * ed + pos;
      float dd = map2( aopos ).x;
      totao += (ed - dd)*sc;
      sc *= .75;
  }
  return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );
}
`});
  }

  function initFuncHelp() {
    let str = FRAG_SHADER_PREFIX + '\n';
    [...magicFuncs.keys()].forEach(k => str += magicFuncs.get(k).code + '\n\n');
    funcEditor = CodeMirror.fromTextArea(document.getElementById("funcstext"), {
      mode: "x-shader/x-fragment",
      lineNumbers: true,
      readOnly: true,
      lineWrapping: true,
      matchBrackets: true,
      foldGutter: true,
      gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
      indentUnit: 2,
    });
    funcEditor.setValue(str);
    CodeMirror.commands.foldAll(funcEditor);

    [...document.getElementsByClassName('collapsible')].forEach(e => {
      e.addEventListener("click", function() {
      this.classList.toggle("active");
      var content = this.nextElementSibling;
      if (content.style.display === "block") {
        content.style.display = "none";
      } else {
        content.style.display = "block";
      }
    })});
    [...document.getElementsByClassName('content')]
    .forEach(e => e.style.display = 'none');
  }

  async function init() {
    initializeMagicFuncs();
    initFuncHelp();
    const code = getUrlParam('code');
    if (!!code) {
      input.value = code;
    }
    configGui.width = canvas.parentElement.parentElement.clientWidth / 2.0;
    editor = CodeMirror.fromTextArea(document.getElementById("textarea"), {
      mode: "x-shader/x-fragment",
      lineNumbers: true,
      lineWrapping: true,
      matchBrackets: true,
      foldGutter: true,
      gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
      extraKeys: { "Ctrl-Space": "autocomplete",
      "Ctrl-Q": function(cm){ cm.foldCode(cm.getCursor()); } },
      indentUnit: 2,
    });
    editor.getWrapperElement().style.height = '100%';
    /* Auto compile */
    editor.on('change', () => {
      if (!autoCompile) {
        return;
      }
      if (triggerCompilerTimeout) {
        clearTimeout(triggerCompilerTimeout);
      }
      setTimeout(() => {
        compilePromise = compile();
      }, AUTO_COMPILE_DELAY_MS);
    });
    gBuffers = initBuffers(gl);
    compilePromise = compile();
    await compilePromise;
    resizeCanvas();
    gUniforms.get('main_light_color').value = [0.8, 0.8, 0.8];
    gUniforms.get('back_light_color').value = [0.9, 0.3, 0.3];
    gUniforms.get('main_light_dir').value = [2.55, 1., 1.6];
    gUniforms.get('main_light_intensity').value = 7.94;
    gUniforms.get('back_light_intensity').value = 0.5;
    onUniformUpdate();
    createUniformGui();

    if (!localStorage.getItem('help_shown')) {
      SnackBar({
        message: 'Press Alt/Ctrl + H for help',
        timeout: 5000
      });
    }
  }

  init();

  function defaultValueForType(type) {
    switch (type) {
      case 'bool':
        return false;
      case 'int':
        return 0;
      case 'float':
        return 0.0;
      case 'vec2':
        return [0.0, 0.0];
      case 'vec3':
      case 'col':
        return [0.0, 0.0, 0.0];
      case 'vec4':
        return [0.0, 0.0, 0.0, 0.0];
    }
    return '';
  }

  function extractUniforms(str) {
    const uniforms = [...str.matchAll(autoUniformRegex)];
    const uniformNames = new Set(uniforms.map(u => u[2]));
    // Remove uniforms that don't exist anymore.
    let deletedVals = [];
    [...gUniforms.keys()]
      .filter(x => !uniformNames.has(x)).forEach(u => {
        deletedVals.push(gUniforms.get(u));
        gUniforms.delete(u);
      });
    // Add new uniforms.
    uniforms.forEach(u => {
      if (!gUniforms.has(u[2]) || !isSameType(gUniforms.get(u[2])['type'], u[1])) {
        gUniforms.set(u[2],
          {
            type: u[1],
            value: deletedVals.length == 1 &&
              isSameType(deletedVals[0].type, u[1]) ?
              deletedVals[0].value : defaultValueForType(u[1])
          });
      } else if (isSameType(gUniforms.get(u[2])['type'], u[1])) {
        gUniforms.get(u[2]).type = u[1];
      }
    });
    createUniformGui();
  }

  function isSameType(type1, type2) {
    let t1 = type1 == 'col' ? 'vec3' : type1,
      t2 = type2 == 'col' ? 'vec3' : type2;
    return t1 == t2;
  }

  function getUniformString() {
    let str = '';
    gUniforms.forEach((u, name) => {
      const type = u.type == 'col' ? 'vec3' : u.type;
      str += `uniform ${type} ${name};`;
    });
    return str;
  }

  function prevWord(code, index) {
    while (index >= 0 && code[index].match(/\s/)) { index--; }
    let firstIndex = index;
    while (firstIndex >= 0 && code[firstIndex].match(/[a-z\d]/)) { firstIndex-- };
    return code.substr(firstIndex + 1, index - firstIndex);
  }

  function addMagicFuncs(code) {
    if (!configGui.builtin_funcs) { return ''; }
    const keywordsregex = /float|int|vec2|vec3|vec4/;
    const regex = new RegExp([...magicFuncs.keys()]
      .map(x => `${x}\\(`).join('\|'), 'g');
    const used = [...code.matchAll(regex)];
    const functionsToAvoid = new Set();
    const functionsToAdd = new Set();
    used.forEach(m => {
      const fname = m[0].substr(0, m[0].length - 1);
      if (prevWord(code, m.index - 1).match(keywordsregex)) {
        functionsToAvoid.add(fname);
      } else if (!functionsToAvoid.has(fname)) {
        functionsToAdd.add(fname);
      }
    });
    // Ugly code below.
    let str = '';
    const addFunc = f => {
      if (functionsToAvoid.has(f)) { return; }
      const funcDetails = magicFuncs.get(f);
      // Recursively add dependencies.
      funcDetails.deps?.forEach(d => addFunc(d));
      str += `${funcDetails.code}\n`
      functionsToAvoid.add(f);
    };
    functionsToAdd.forEach(f => addFunc(f));
    return str;
  }

  function resizeCanvas() {
    if (!document.fullscreenElement) {
      canvas.classList.remove('floatingViewer');
      canvas.style.width = `${configGui.width}px`;
      canvas.style.height = `${configGui.width / configGui.aspect_ratio}px`;
    }
    const dpr = window.devicePixelRatio;
    const displayWidth = Math.round(canvas.clientWidth * dpr);
    const displayHeight = Math.round(canvas.clientHeight * dpr);
    if (canvas.width == displayWidth && canvas.height == displayHeight) {
      return;
    }
    canvas.width = displayWidth;
    canvas.height = displayHeight;
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    controls.style.width = `${canvas.clientWidth}px`;
    texturesElem.style.width = `${canvas.clientWidth}px`;
    onUniformUpdate();
    updateCodeEditorType();
  }

  function createReconfigGui() {
    animateController = gui.add(configGui, 'animate').onChange(() => {
      handleAnimateChange();
    });
    gui.add(window, 'autoCompile');
    gui.add(configGui, 'builtin_funcs');

    const storageFolder = gui.addFolder('storage');
    storageFolder.add(configGui, 'clearStorage');
    storageFolder.add(configGui, 'quickSave');
    storageFolder.add(configGui, 'quickLoad');
    const f = gui.addFolder('Sizing');
    sizeControllers = [];
    sizeControllers.push(f.add(configGui, 'aspect_ratio', undefined, undefined, 0.01)
      .onChange(() => resizeCanvas()));
    sizeControllers.push(f.add(configGui, 'width', 200, window.innerWidth)
      .onChange(() => resizeCanvas()));

    const f2 = gui.addFolder('Mouse');
    f2.add(configGui, 'endlessMouse');
    mouseControllers = [];
    mouseControllers.push(f2.add(mouse, 'x', undefined, undefined, 5)
      .onChange(() => onUniformUpdate()));
    mouseControllers.push(f2.add(mouse, 'y', undefined, undefined, 5)
      .onChange(() => onUniformUpdate()));
    mouseControllers.push(f2.add(mouse, 'z', undefined, undefined, 5)
      .onChange(() => onUniformUpdate()));
  }

  function createUniformGui() {
    gui.destroy();
    guiControllers.clear();
    uniformsGui = {};
    gui = new dat.GUI();
    createReconfigGui();
    gui.hide();
    gUniforms.forEach((u, name) => {
      switch (u.type) {
        case 'bool':
          uniformsGui[name] = u.value;
          guiControllers.set(name,
            gui.add(uniformsGui, name).onChange(() => {
              u.value = uniformsGui[name];
              onUniformUpdate();
            }));
          return;
        case 'int':
        case 'float':
          uniformsGui[name] = u.value;
          guiControllers.set(name,
            gui.add(uniformsGui, name, undefined, undefined, 0.01).onChange(() => {
              u.value = uniformsGui[name];
              onUniformUpdate();
            }));
          return;
        case 'vec2':
        case 'vec3':
        case 'vec4':
          uniformsGui[`${name}.x`] = u.value[0];
          guiControllers.set(name,
            gui.add(uniformsGui, `${name}.x`, undefined, undefined, 0.01).onChange(() => {
              u.value[0] = uniformsGui[`${name}.x`];
              onUniformUpdate();
            }));
          uniformsGui[`${name}.y`] = u.value[1];
          guiControllers.set(name,
            gui.add(uniformsGui, `${name}.y`, undefined, undefined, 0.01).onChange(() => {
              u.value[1] = uniformsGui[`${name}.y`];
              onUniformUpdate();
            }));
          if (u.type != 'vec2') {
            uniformsGui[`${name}.z`] = u.value[2];
            guiControllers.set(name,
              gui.add(uniformsGui, `${name}.z`, undefined, undefined, 0.01).onChange(() => {
                u.value[2] = uniformsGui[`${name}.z`];
                onUniformUpdate();
              }));
          }
          if (u.type == 'vec4') {
            uniformsGui[`${name}.w`] = u.value[3];
            guiControllers.set(name,
              gui.add(uniformsGui, `${name}.w`, undefined, undefined, 0.01).onChange(() => {
                u.value[3] = uniformsGui[`${name}.w`];
                onUniformUpdate();
              }));
          }
          return;
        case 'col':
          uniformsGui[name] = u.value.map(v => v * 255);
          guiControllers.set(name,
            gui.addColor(uniformsGui, name).onChange(() => {
              u.value = uniformsGui[name].map(v => v / 255.0);
              onUniformUpdate();
            }));
      }
    });
  }

  function updateTextures() {
    if (!!textures[0]) {
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, textures[0]);
      gl.uniform1i(gProgramInfo.uniformLocations.tex0, 0);
      gl.uniform2f(gProgramInfo.uniformLocations.res0,
        texture0.naturalWidth, texture0.naturalHeight);
    }

    if (!!textures[1]) {
      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, textures[1]);
      gl.uniform1i(gProgramInfo.uniformLocations.tex1, 1);
      gl.uniform2f(gProgramInfo.uniformLocations.res1,
        texture1.naturalWidth, texture1.naturalHeight);
    }

    if (!!textures[2]) {
      gl.activeTexture(gl.TEXTURE2);
      gl.bindTexture(gl.TEXTURE_2D, textures[2]);
      gl.uniform1i(gProgramInfo.uniformLocations.tex2, 2);
      gl.uniform2f(gProgramInfo.uniformLocations.res2,
        texture2.naturalWidth, texture2.naturalHeight);
    }

    if (!!textures[3]) {
      gl.activeTexture(gl.TEXTURE3);
      gl.bindTexture(gl.TEXTURE_2D, textures[3]);
      gl.uniform1i(gProgramInfo.uniformLocations.tex3, 3);
      gl.uniform2f(gProgramInfo.uniformLocations.res3,
        texture3.naturalWidth, texture3.naturalHeight);
    }
  }

  function updateUniformValues() {
    gUniforms.forEach((u, name) => {
      const loc = gl.getUniformLocation(gShaderProgram, name);
      switch (u.type) {
        case 'bool':
          gl.uniform1i(loc, u.value);
        case 'int':
          gl.uniform1i(loc, u.value);
          return;
        case 'float':
          gl.uniform1f(loc, u.value);
          return;
        case 'vec2':
          gl.uniform2fv(loc, u.value);
          return;
        case 'vec3':
        case 'col':
          gl.uniform3fv(loc, u.value);
          return;
        case 'vec4':
          gl.uniform4fv(loc, u.value);
          return;
      }
    });
  }

  function onUniformUpdate() {
    drawScene(canvas, gl, gProgramInfo, gBuffers);
  }

  function clearSnackbars() {
    [...document.getElementsByClassName('js-snackbar-container')]
      .forEach(e => {
        if (e.getElementsByClassName('js-snackbar--danger').length > 0) {
          e.remove();
        }
      });
    [...Array(editor.lineCount()).keys()]
      .forEach(i => editor.removeLineClass(i, 'background'));
  }

  async function compile() {
    const res = new Promise((resolve, reject) => {
      const code = editor.getValue();
      const magicFuncs = addMagicFuncs(code);
      clearSnackbars();
      extractUniforms(magicFuncs + code);
      const frag_shader_prefix = FLOAT_PRECISION + FRAG_SHADER_PREFIX
       + getUniformString() + magicFuncs;
      const lineShift = frag_shader_prefix.split('\n').length;
      const fShader = frag_shader_prefix + code + FRAG_SHARDER_SUFFIX;
      const shaderProg = initShaderProgram(gl, vsSource, fShader, lineShift);
      if (!shaderProg) {
        reject('failed');
        return;
      }
      SnackBar({
        status: 'success', message: 'Compiled successfully',
        timeout: 1000
      });
      resolve(shaderProg);
    });
    return res.then(newProgram => {
      compilePromise = null;
      gl.deleteProgram(gShaderProgram);
      gShaderProgram = newProgram;
      gProgramInfo = {
        program: gShaderProgram,
        attribLocations: {
          vertexPosition: gl.getAttribLocation(
            gShaderProgram,
            "aVertexPosition"
          ),
        },
        uniformLocations: {
          res: gl.getUniformLocation(gShaderProgram, "res"),
          res0: gl.getUniformLocation(gShaderProgram, "res0"),
          res1: gl.getUniformLocation(gShaderProgram, "res1"),
          res2: gl.getUniformLocation(gShaderProgram, "res2"),
          res3: gl.getUniformLocation(gShaderProgram, "res3"),
          time: gl.getUniformLocation(gShaderProgram, "time"),
          mouse: gl.getUniformLocation(gShaderProgram, "mouse"),
          tex0: gl.getUniformLocation(gShaderProgram, "tex0"),
          tex1: gl.getUniformLocation(gShaderProgram, "tex1"),
          tex2: gl.getUniformLocation(gShaderProgram, "tex2"),
          tex3: gl.getUniformLocation(gShaderProgram, "tex3"),
        },
      };
      drawScene(canvas, gl, gProgramInfo, gBuffers);
    });
  }

  timeElem.addEventListener('mousedown', (ev) => {
    selectedElem = timeElem;
    timeElem.requestPointerLock();
  });

  canvas.addEventListener('mousedown', (ev) => {
    selectedElem = canvas;
    if (configGui.endlessMouse) {
      canvas.requestPointerLock();
    }
  });

  canvas.addEventListener('mousemove', (ev) => {
    if (selectedElem == canvas) {
      if (!configGui.endlessMouse) {
        mouse = {
          x: (ev.offsetX) * canvas.width / canvas.clientWidth,
          y: (canvas.clientHeight - ev.offsetY) * canvas.height / canvas.clientHeight
        };
      } else {
        if (ev.metaKey || ev.altKey) {
          configGui.width += ev.movementX * (ev.shiftKey ? 10. : 1.);
          const newHeight = canvas.clientHeight - ev.movementY * (ev.shiftKey ? 10. : 1.);
          configGui.aspect_ratio = configGui.width / newHeight;
          sizeControllers.forEach(c => c.updateDisplay());
          resizeCanvas();
        } else {
          mouse.x -= ev.movementX * (ev.shiftKey ? 10. : 1.);
          mouse.y += ev.movementY * (ev.shiftKey ? 10. : 1.);
          mouseControllers.forEach(c => c.updateDisplay());
        }
      }
      onUniformUpdate();
    }
  });

  timeElem.addEventListener("focusout", () => {
    if (timeElem.innerText.length == 0 || timeElem.innerText == '.') {
      timeElem.innerText = '0.00';
    }
    onUniformUpdate();
  });
  timeElem.onkeypress = event => {
    let key = String.fromCharCode(event.keyCode);
    const curPos = window.getSelection().getRangeAt(0).startOffset;
    const dotPos = timeElem.innerText.search(/\./);
    const isDigit = /[0-9]|\./.test(key);
    if (!isDigit || (key == '.' && dotPos >= 0)) {
      event.preventDefault();
    }
  };
  timeElem.oninput = () => {
    onUniformUpdate();
  }

  function updateCodeEditorType() {
    if (canvas.clientWidth >= canvas.parentElement.parentElement.clientWidth * 0.6) {
      codeElem.classList.add('floatingEditor');
    } else {
      codeElem.classList.remove('floatingEditor');
    }
  }

  window.addEventListener('mousemove', ev => {
    if (selectedElem === timeElem) {
      let curTime = parseFloat(timeElem.innerText);
      curTime -= (ev.movementY - ev.movementX) / (ev.shiftKey ? 10. : 100.);
      timeElem.innerText = curTime.toFixed(3);
      onUniformUpdate();
    }
    return true;
  });

  window.addEventListener('resize', ev => {
    resizeCanvas();
  });

  window.addEventListener('mouseup', ev => {
    selectedElem = null;
    document.exitPointerLock();
  });

  window.addEventListener('keydown', (event) => {
    if (event.code == 'Backquote' && !event.ctrlKey) {
      if (codeElem.style.display == 'none') {
        codeElem.style.display = 'flex';
        updateCodeEditorType();
      } else {
        codeElem.style.display = 'none';
      }
      event.preventDefault();
    } else if (event.code == 'Backquote' && event.ctrlKey) {
      if (commandElem.style.display == 'none') {
        commandElem.style.display = '';
        commandElem.focus();
      } else {
        commandElem.style.display = 'none';
        commandElem.value = '';
      }
      event.preventDefault();
    } else if (event.code == 'Digit1' && (event.metaKey || event.ctrlKey)) {
      if (gui.domElement.style.display == 'none') {
        gui.show();
      } else {
        gui.hide();
      }
      event.preventDefault();
    } else if (event.code == 'Digit2' && (event.metaKey || event.ctrlKey)) {
      if (controls.style.display == 'none') {
        controls.style.display = 'flex';
      } else {
        controls.style.display = 'none';
      }
      event.preventDefault();
    } else if (event.code == 'Digit3' && (event.metaKey || event.ctrlKey)) {
      if (texturesElem.style.display == 'none') {
        texturesElem.style.display = 'flex';
      } else {
        texturesElem.style.display = 'none';
      }
      event.preventDefault();
    } else if (event.code == 'Enter' && (event.metaKey || event.altKey || event.ctrlKey)) {
      compilePromise = compile();
      event.preventDefault();
    } else if (event.code == 'KeyF' && event.altKey) {
      if (document.fullscreenElement) {
        document.exitFullscreen();
      } else {
        codeElem.style.display = 'none'
        canvas.style.width = '';
        canvas.style.height = '';
        canvas.classList.add('floatingViewer');
        document.documentElement.requestFullscreen();
      }
      event.preventDefault();
    } else if (event.code == 'ArrowUp' && event.altKey) {
      animateController.setValue(!configGui.animate);
    } else if (event.code == 'ArrowDown' && event.altKey) {
      timeElem.innerText = '0.000';
      onUniformUpdate();
    } else if (event.code == 'KeyE' && (event.metaKey || event.ctrlKey)) {
      event.preventDefault();
      const selection = editor.getSelection();
      const typeAndVal = inferVariableTypeAndValue(selection);
      if (typeAndVal.type != '') {
        extractUniform(typeAndVal);
      } else if (gUniforms.has(selection)) {
        insertUniform(selection);
      }
    } else if (event.code == 'KeyS' && (event.metaKey || event.ctrlKey)) {
      event.preventDefault();
      configGui.quickSave();
      const params = new URLSearchParams();
      params.set('code', editor.getValue());
      navigator.clipboard.writeText(
        `${getUrlWithoutParams()}?${params.toString()}`
      );
    } else if (event.code == 'KeyO' && (event.metaKey || event.ctrlKey)) {
      event.preventDefault();
      configGui.quickLoad();
    } else if (event.code == 'KeyH' && (event.ctrlKey || event.altKey)) {
      dialogElement.showModal();
      localStorage.setItem('help_shown', true);
    }
  });

  function getUrlWithoutParams() {
    return location.protocol + '//' + location.host + location.pathname;
  }

  function getUrlParam(name) {
    const params = new URLSearchParams(window.location.search);
    return params.get(name);
  }

  function insertUniform(name) {
    const uniform = gUniforms.get(name);
    const replaceStr = `/*${uniform.type}*/${name}`;
    const sc = editor.getSearchCursor(replaceStr);
    if (!sc.find()) {
      return;
    }
    let val = uniform.value;
    if (Array.isArray(val)) {
      val = `vec${val.length}(${val.map(x => x.toFixed(3)).join(',')})`;
    } else if (uniform.type == 'float' && String(val).indexOf('.') < 0) {
      val = val.toFixed(1);
    }
    sc.replace(String(val), replaceStr);
    compile();
  }

  function extractUniform(typeAndVal) {
    const varName = addVariableWithType(typeAndVal);
    editor.replaceSelection(`/*${typeAndVal.type}*/${varName}`);
    compile();
  }

  function addVariableWithType(typeAndVal) {
    for (let i = 0; i < 100; i++) {
      const name = `${typeAndVal.type}_var_${i}`;
      if (gUniforms.has(name)) {
        continue;
      }
      gUniforms.set(name, { type: typeAndVal.type, value: typeAndVal.val });
      return name;
    }
    return '';
  }

  /**
   * @param {string} variable
   */
  function inferVariableTypeAndValue(variable) {
    variable = variable.trim();
    let val = [];
    let type = '';
    if (variable.startsWith('vec2')) {
      val = [...variable.matchAll(vec2Vals)][0]
        ?.slice(1)?.map(x => parseFloat(x));
      type = 'vec2';
    } else if (variable.startsWith('vec3')) {
      val = [...variable.matchAll(vec3Vals)][0]
        ?.slice(1)?.map(x => parseFloat(x));
      type = 'vec3';
    } else if (variable.startsWith('vec4')) {
      val = [...variable.matchAll(vec4Vals)][0]
        ?.slice(1)?.map(x => parseFloat(x));
      type = 'vec4';
    } else if (variable.indexOf('.') >= 0) {
      val = parseFloat(variable);
      type = 'float';
    } else if (variable == 'false' || variable == 'true') {
      val = variable == 'true';
      type = 'bool';
    } else {
      val = parseInt(variable);
      type = 'int';
    }
    if (!!val) {
      return { type, val };
    }
    return { type: '' };
  }

  function handleAnimateChange() {
    if (configGui.animate) {
      requestAnimationFrame(animate);
    }
  }

  function animate(timestamp) {
    if (lastTimestamp) {
      const elapsed = timestamp - lastTimestamp;
      // Update time.
      let curTime = parseFloat(timeElem.innerText);
      curTime += elapsed / 1000.0;
      timeElem.innerText = curTime.toFixed(3);

      // Update FPS.
      if (timestamp - lastFpsTimestamp > 700) {
        const fps = framesCount / (timestamp - lastFpsTimestamp) * 1000.0;
        fpsElem.innerText = fps.toFixed(2);
        framesCount = 0;
        lastFpsTimestamp = timestamp;
      }
    }
    onUniformUpdate();
    framesCount++;
    if (configGui.animate) {
      lastTimestamp = timestamp;
      if (!lastFpsTimestamp) {
        lastFpsTimestamp = timestamp;
        framesCount = 1;
      }
      requestAnimationFrame(animate);
    } else {
      lastTimestamp = null;
      lastFpsTimestamp = null;
    }
  }

  commandElem.addEventListener('keydown', (event) => {
    if (event.code == 'Enter') {
      let execStr = commandElem.value;
      let guiVar = [...commandElem.value.matchAll(assignmentRegex)];
      if (guiVar.length == 1 && gUniforms.has(guiVar[0][1])) {
        const newValStr = execStr.substr(guiVar[0][0].length);
        execStr = `interpolate('${guiVar[0][1]}', ${newValStr});`;
        console.info(execStr);
      }
      try {
        let result = eval(execStr);
        SnackBar({ status: 'success', message: result, timeout: 1000 });
      } catch (error) {
        SnackBar({ status: 'error', message: error, timeout: 3000 });
        return;
      }
      commandElem.style.display = 'none';
      commandElem.value = '';
    }
  });

  canvas.onwheel = ev => {
    mouse.z += ev.shiftKey? 10. * ev.deltaY : 2.*ev.deltaY;
    mouseControllers.forEach(c => c.updateDisplay());
    onUniformUpdate();
  };

  canvas.ondragover = ev => {
    ev.preventDefault();
  };

  allTextures.forEach((v, i) => {
    v.ondragover = ev => ev.preventDefault();
    v.onclick = ev => {
      if (textures[i]) {
        gl.deleteTexture(textures[i]);
        textures[i] = null;
      }
      v.setAttribute('src', '');
      onUniformUpdate();
    }
    v.ondrop = ev => {
      ev.stopPropagation();
      ev.preventDefault();

      const htmlData = ev.dataTransfer.getData('text/html');
      const rex = /src="?([^"\s]+)"?\s*/;
      v.src = rex.exec(htmlData)[1];
      v.onload = () => {
        if (textures[i]) {
          gl.deleteTexture(textures[i]);
          textures[i] = null;
        }
        textures[i] = createTexture(v);
        onUniformUpdate();
      };
    }
  });

  canvas.ondrop = ev => {
    ev.preventDefault();

    if (ev.dataTransfer.items) {
      for (var i = 0; i < ev.dataTransfer.items.length; i++) {
        if (ev.dataTransfer.items[i].kind != "file") {
          continue;
        }
        var file = ev.dataTransfer.items[i].getAsFile();
        createImageBitmap(file).then((img) => {
        });
      }
    }
  };

  function mix(a, b, x) {
    if (Array.isArray(a)) {
      return a.map((v, i) => v * (1.0 - x) + b[i] * x);
    }
    return a * (1.0 - x) + b * x;
  }


  function linstep(a, b, x) {
    return Math.max(0.0, Math.min(1.0, (x - a) / (b - a)));
  }

  function smoothstep(a, b, x) {
    const t = linstep(a, b, x);
    return t * t * (3.0 - 2.0 * t);
  }

  function expEaseOut(a, b, x) {
    const t = linstep(a, b, x);
    return t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
  }

  function interpolate(name, toVal, durationMs = 1000., func = expEaseOut) {
    let start, end;
    let fromVal = gUniforms.get(name).value;
    if (Array.isArray(fromVal)) {
      fromVal = [...fromVal];
    }
    const updateFunc = (timestamp) => {
      if (start === undefined) {
        start = timestamp;
        end = start + durationMs;
      }
      if (timestamp < end) {
        let newVal = mix(fromVal, toVal, func(start, end, timestamp));
        gUniforms.get(name).value = newVal;
        requestAnimationFrame(updateFunc);
      } else {
        gUniforms.get(name).value = toVal;
        createUniformGui();
      }
      onUniformUpdate();
    }
    requestAnimationFrame(updateFunc);
  }

</script>

</html>